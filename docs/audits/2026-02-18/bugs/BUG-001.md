# [BUG-001]: Token Expiry Seconds vs Milliseconds Ambiguity

## Severity
LOW

## Type
Edge Case

## Location
- File: `apps/web-app/src/services/auth-service.ts`
- Function: Token expiry parsing

## Description
The web app parses the JWT expiry timestamp from localStorage as an integer via `parseInt(expiresAtStr, 10)`. The OAuth worker returns `expires_at` as a Unix timestamp in seconds. However, there is no explicit validation or documentation asserting the unit (seconds vs. milliseconds).

If the OAuth worker ever accidentally returns milliseconds (e.g., `Date.now()` instead of `Math.floor(Date.now() / 1000)`), the `isAuthenticated()` check would compare seconds against milliseconds, causing tokens to appear valid far into the future.

## Reproduction Scenario
1. OAuth worker accidentally sets `expires_at = Date.now()` (milliseconds)
2. Web app stores this value in localStorage
3. `isAuthenticated()` compares `Date.now() / 1000` against the millisecond value
4. Token appears valid until year ~65,000

## Evidence
```typescript
// Web app checks expiry
const expiresAt = parseInt(expiresAtStr, 10);
const now = Math.floor(Date.now() / 1000);
return now < expiresAt; // Works only if expiresAt is in seconds
```

## Suggested Fix
```typescript
// Add validation that expiry is a reasonable Unix timestamp (seconds)
const expiresAt = parseInt(expiresAtStr, 10);
if (expiresAt > 1e12) {
  // Likely milliseconds - convert to seconds
  console.warn('Token expiry appears to be in milliseconds, converting');
  expiresAt = Math.floor(expiresAt / 1000);
}
```

## Why It's Hidden
- Both producer (OAuth worker) and consumer (web app) currently agree on seconds
- Would only manifest if the OAuth worker's token generation logic changes
- Standard JWT `exp` claim is always in seconds per RFC 7519, but the app uses a custom `expires_at` field

---

## Resolution Note (2026-02-19) — Fixed in web-app 4.1.7

`apps/web-app/src/services/auth-service.ts` `handleCallbackToken()`: Added a millisecond detection
guard — if the parsed `expiresAt` value exceeds `1e12` (which no seconds-based Unix timestamp will
reach until the year ~33,658), it is divided by 1000 and a warning is logged. A real 2026 timestamp
in seconds is ~1.77×10⁹, well below the threshold.
