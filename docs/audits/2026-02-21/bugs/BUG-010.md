# BUG-010: `Memory.pruneOldestEntries` Uses `Math.max(...timestamps)` â€” Stack Overflow Risk

## Severity
LOW

## Type
Resource Management

## Location
- File: `packages/rate-limiter/src/backends/memory.ts`
- Line(s): ~171-195
- Function: `pruneOldestEntries()`

## Description
When pruning entries, the code uses `Math.max(...timestamps)` which spreads the full timestamp array onto the call stack. For keys with many requests (e.g., DDoS traffic generating thousands of timestamps per key), this can cause a stack overflow.

## Evidence
```typescript
const entries: Array<{ key: string; lastActivity: number }> = [];
this.requestLog.forEach((timestamps, key) => {
  const lastActivity = timestamps.length > 0 ? Math.max(...timestamps) : 0;
  entries.push({ key, lastActivity });
});
entries.sort((a, b) => a.lastActivity - b.lastActivity);
```

## Suggested Fix
Use `timestamps[timestamps.length - 1]` instead of `Math.max(...timestamps)` since timestamps are appended in chronological order:

```typescript
const lastActivity = timestamps.length > 0 ? timestamps[timestamps.length - 1] : 0;
```

## Why It's Hidden
Normal usage generates modest timestamp arrays. The issue only manifests under heavy load (thousands of requests per key), which is exactly the DDoS scenario where rate limiting is most critical.
