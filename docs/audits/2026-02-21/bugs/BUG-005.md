# BUG-005: Memory Backend `remaining` Semantics Inconsistent with KV

## Severity
MEDIUM

## Type
Logic Inconsistency

## Location
- File: `packages/rate-limiter/src/backends/memory.ts`
- Line(s): ~88-111
- Function: `check()`

## Description
The Memory backend computes `remaining` before recording the request, then adjusts it post-hoc with `remaining - 1` for allowed requests. The KV backend computes it differently. This means the same rate limiter configuration reports different `remaining` values depending on which backend is used, creating unpredictable behavior when switching backends (e.g., Memory in dev, KV in production).

## Evidence
```typescript
// Memory backend:
const remaining = Math.max(0, effectiveLimit - recentTimestamps.length);
return {
  allowed,
  remaining: allowed ? remaining - 1 : remaining,
};

// KV backend computes differently:
const remaining = Math.max(0, effectiveLimit - entry.count - 1);
```

## Suggested Fix
Align the semantics across all backends. Define `remaining` as "requests left after this one" and compute it consistently.

## Why It's Hidden
In most usage scenarios, the `remaining` count is only used for header values (e.g., `X-RateLimit-Remaining`). The difference of 1 between backends isn't noticed unless consumers switch backends or compare behavior directly.
