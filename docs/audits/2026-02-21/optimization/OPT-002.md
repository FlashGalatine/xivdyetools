# OPT-002: CryptoKey Re-Imported on Every HMAC Operation

## Impact
MEDIUM

## Category
I/O / Crypto

## Location
- Files: `packages/auth/src/hmac.ts`, `packages/auth/src/jwt.ts`
- Functions: `hmacSign`, `hmacVerify`, `hmacSignHex`, `hmacVerifyHex`, `verifyJWT`, `verifyJWTSignatureOnly`

## Current Performance
Every call imports the raw secret string as a new `CryptoKey` via `crypto.subtle.importKey()`. In a Cloudflare Worker handling many requests with the same secret, this is repeated per-request.

## Bottleneck Analysis
`crypto.subtle.importKey()` is an asynchronous operation that involves:
- UTF-8 encoding the secret string
- Creating a new CryptoKey object
- Internal crypto subsystem overhead

With multiple JWT verifications per request (e.g., access token + bot signature), this multiplies.

## Proposed Optimization
Allow callers to pass a pre-imported `CryptoKey`, or add a module-level cache:

```typescript
const keyCache = new Map<string, CryptoKey>();

async function getOrImportKey(secret: string, usage: KeyUsage[]): Promise<CryptoKey> {
  const cacheKey = `${secret.length}:${usage.join(',')}`;
  let key = keyCache.get(cacheKey);
  if (!key) {
    key = await createHmacKey(secret, ...);
    keyCache.set(cacheKey, key);
  }
  return key;
}
```

**Important:** In Workers, module-level state persists across requests within an isolate, making this safe and effective.

## Expected Improvement
Eliminates ~1-2 async crypto operations per request after first cold start.

## Trade-offs
- Must be careful with memory â€” the cache should be bounded
- Different secrets (e.g., rotation) need cache invalidation
